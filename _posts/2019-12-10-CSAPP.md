---
layout: post
title: 深入理解计算机系统CSAPP-美-布莱恩特
date: 2019-12-18
tags: 读书
---

# 深入理解计算机系统CSAPP-美-布莱恩特

## 计算机系统漫游

这一个章节主要从一个hello world程序出发，串联了计算机系统的整个流程。串联路径为：信息就是bit加上下文 => 程序被其他程序翻译成不同格式 => 了解编译系统能让你写出高效安全的代码 => 处理器读并解析存储在内存中的指令 => 总线 => I/O设备 => (人类是复读机，计算机是复制机) => 运行hello程序 => 高速缓存 => 存储设备形成层次，上一个设备是下一个设备的缓存 => 进程 => 线程 => 虚拟内存，虚拟地址空间 => 文件 => 系统之间利用网络通信 => 多核 => 超线程 => 超标量处理器一个时钟周期处理多于一条的指令

## 信息的表示和处理

虚拟内存指的是计算机的内存管理技术，它使得应用程序以为自己在访问一段连续的可用内存，实际上，它访问的内存并不连续，甚至有可能使用磁盘充当内存。

我们所说的32位程序和64位程序，区别在于它是怎么编译的，如```gcc -m32 hello.c```表示它是32位程序，而```gcc -m64 hello.c```表示它是64位程序，需要注意的是，64位程序无法在32位机器上运行，而32位程序可以在32位和64位机器上运行。 

位运算的快捷计算方式：
```
相与取最小，如01&10=00，按位取最小。相或取最大，如01 | 10 = 11。异或做加法，如11 ^ 11 = 00，1+1=0，进位1，舍弃进位。
```

补码的理解，可以认为补码的第一位是负权，如1000 0000表示的是-1*2^8=-128，比起原补码的理解：负数位取反加1，即000 0000取反为111 1111加1为1000 0000的计算更快。当然，如果计算十进制转二进制的补码形式，还是需要取反加1的。

## 程序的机器级表示

虽然C语言中提供了各种数据类型，但是机器代码只是简单地把内存看成一个很大的数组，并不区分有符号和无符号，不区分各种类型地指针。

程序内存用虚拟地址来寻址，x86-64的虚拟地址是由64位的字来表示，其高16位被置0，所以一地址实际上指定的是2^48=64TB。

汇编产生的机器码从1到15个字节不等，常用的指令和操作数较少的指令会较短。指令格式的设计是唯一的，比如，只有指令pushq %rbx是以字节值53开头的。

连接器的作用是将多个目标文件连接起来，找到主程序调用其他程序的调用地址。

C文件的编译过程：
+ 预编译，include文件展开了：gcc -Og -E -o main.i main.c
+ 编译，编译成了汇编语言：gcc -Og -S main.c
+ 汇编，编译成了机器语言，如果使用objdump反编译，可以看到函数调用是使用偏移量的：gcc -Og -c main.c
+ 链接，反编译后的地址使用的是真实地址：gcc -Og -o prop main.c mstore.c

以上可以看到，预编译，编译和汇编都可以一个文件完成，只有链接才需要多个文件

内存寻址的通用模式为：Imm + R[rb] + R[ri] * s，其中Imm指的是立即数，rb指的是基址寄存器，ri表示变址，s表示比例因子1，2，4，8。引用数组时，会使用这种通用格式。

函数调用的过程中，先将参数入栈，再将IP指针入栈，寄存器分为两组类型，一个是调用者维护，即被调用函数可能修改该组寄存器的值，需调用者在调用函数前自行保存。第二种是被调用者维护，即被调用者需要修改该组寄存器时先将值入栈，调用完毕时恢复，使得函数返回对于调用者无影响。

数据对齐：数据存放的地址能够被其字节长度整除，如int类型为4个字节，如果一个int值放在了地址为4n的地方，则表示这个数据是对齐的。C语言中char为一个字节，所以放在哪里都是对齐的。对齐可以提高CPU读取速度，因为有些CPU的设计是自从偶数地址读起，如果值存放在奇数地址，那需要读取两次再拼凑出该值。

## 处理器体系结构

寄存器也是有编号的。

时钟是用来同步逻辑门的写入，只有在时钟上升沿才会写入。所谓的超频，就是提高计算机的时钟频率，加快了计算机的写入速度。

一般CPU都会表频率为4GHz等等，表示计算机每秒有4G的时钟周期，同品牌CPU，频率越快越好。

## 在系统上运行程序

C语言源代码，通过预编译 => 编译 => 汇编 => 链接，可以形成可执行文件。其中汇编生成的目标字节文件从0地址开始，符号地址都是使用偏移量来定位。链接器的作用是将重定位的功能，将每个符号地址与一个内存位置关联，然后修改对这些符号的引用从而重定位这些符号地址。

那么，链接器是怎么工作的呢？每一个C源代码中都有变量、函数名等，这些符号汇编成二进制目标文件后，会保存在目标文件的符号表中。如
```c
int sum(int *a, int n);

int array[2] = {1, 2};

int main(){
  int val = sum(array, 2);
  return val;
}
```
以上这段程序有sum, array, main这三个符号，而main内部的局部变量分配在运行时的栈中，故不在符号变量中。链接器运行时，会解析每一个符号，如下图中的U sum表示sum函数undefine未定义，故链接器会在其他链接模块中查找该符号。查找不到会报错：undefined reference to 'sum'.

![20191222145352.png](https://i.loli.net/2019/12/22/shHymBuWXpKIv2t.png)

链接器有一个缺点，就是如果链接器是怎个链接的，两个输入文件会完成链接在一起。对于系统级别的函数库如果每个文件都保留有完全副本，那就是浪费。这时，静态库可以解决这个问题。

静态库：将相关的目标文件打包，即为静态库，可以作为链接器的输入。链接时链接器复制静态库中需要使用的符号代码。然而链接器是严格按照命令行输入的文件顺序执行的，如果把静态库放在目标文件前，将无法重定位到目标文件中的符号。

汇编后的目标文件，汇编器它并不知道引用的外部符号的地址。此时汇编器会生成重定位条目，并在对应位置预留字节占位，链接器会根据重定位条目设置字节占位。

每个程序运行时都用内存映像，顺序为代码段 => 数据段 => 堆 => 共享模块保留内存段 => 栈 => 内核区。其中代码段开始于地址0x400000，栈开始于2^48-1并向低地址扩张。

链接器除了静态链接器还有动态链接器，可执行文件可以是部分链接的可执行文件，在执行时使用动态链接器链接成内存中的完全可执行文件。

## 异常控制流

私有地址空间：进程为每个程序提供一种假象，好像它独占的使用系统地址空间。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程多或写的，从这个意义上来说，这个地址空间是私有的。每个进程的内存结构又是相同的，如0x400000地址开始存放的是代码段，0^48-1以下的是栈空间。

## 虚拟内存

操作系统为每一个进程维护了一张页表存放虚拟内存地址，进程使用内存时需要操作系统查页表得到物理内存地址。

